/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef CLI_H_
#define CLI_H_

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

namespace cli
{

    // ********************************************************************

    template < typename T > struct TypeDesc {};
    template <> struct TypeDesc< char > { static const char* Name() { return "<char>"; } };
    template <> struct TypeDesc< unsigned char > { static const char* Name() { return "<unsigned char>"; } };
    template <> struct TypeDesc< short > { static const char* Name() { return "<short>"; } };
    template <> struct TypeDesc< unsigned short > { static const char* Name() { return "<unsigned short>"; } };
    template <> struct TypeDesc< int > { static const char* Name() { return "<int>"; } };
    template <> struct TypeDesc< unsigned int > { static const char* Name() { return "<unsigned int>"; } };
    template <> struct TypeDesc< long > { static const char* Name() { return "<long>"; } };
    template <> struct TypeDesc< unsigned long > { static const char* Name() { return "<unsigned long>"; } };
    template <> struct TypeDesc< float > { static const char* Name() { return "<float>"; } };
    template <> struct TypeDesc< double > { static const char* Name() { return "<double>"; } };
    template <> struct TypeDesc< long double > { static const char* Name() { return "<long double>"; } };
    template <> struct TypeDesc< bool > { static const char* Name() { return "<bool>"; } };
    template <> struct TypeDesc< std::string > { static const char* Name() { return "<string>"; } };

    // ********************************************************************

    // forward declarations
    class Menu;
    class CliSession;

    class Cli
    {
    public:
        Cli(
            std::unique_ptr< Menu >&& rootMenu,
            std::function< void(std::ostream&) > exitAction = std::function< void(std::ostream&) >()
        );

        // disable value semantics
        Cli( const Cli& ) = delete;
        Cli& operator = ( const Cli& ) = delete;

        void ExitAction( std::function< void(std::ostream&)> action );
        Menu* RootMenu() { return rootMenu.get(); }
        bool ScanCmds( const std::vector< std::string >& cmdLine, CliSession& session );
        void MainHelp( std::ostream& out );
        void ExitAction( std::ostream& out ) { if ( exitAction ) exitAction( out ); }
    private:
        void Help( std::ostream& out );
        std::unique_ptr< Menu > rootMenu; // just to keep it alive
        std::unique_ptr< Menu > global;
        std::function< void(std::ostream&) > exitAction;
    };

    // ********************************************************************

    class Command
    {
    public:
        virtual ~Command() = default;
        virtual bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) = 0;
        virtual void Help( std::ostream& out ) = 0;
    };

    // ********************************************************************

    class CliSession
    {
    public:
        CliSession( Cli& _cli, std::ostream& _out ) :
            cli( _cli ),
            current( cli.RootMenu() ),
            run( true ),
            out( _out )
        {}

        // disable value semantics
        CliSession( const CliSession& ) = delete;
        CliSession& operator = ( const CliSession& ) = delete;

        bool Feed( const std::string& cmd );

        void Prompt();

        void Run()
        {
            std::string cmd;
            while ( run )
            {
                Prompt();
                std::getline( std::cin, cmd );
                if ( ! Feed( cmd ) ) break;
            }
        }

        void Current( Menu* menu )
        {
            current = menu;
        }

        std::ostream& OutStream() { return out; }

        void Help();

        void Add( std::unique_ptr< Command >&& cmd )
        {
            cmds.push_back( std::move(cmd) );
        }

        template < typename F >
        void Add( const std::string& name, F f, const std::string& help = "" )
        {
            // dispatch to private Add methods
            Add( name, help, f, &F::operator() );
        }

        void Exit()
        {
            run = false;
            if ( exitAction ) exitAction( out );
        }

        void ExitAction( std::function< void(std::ostream&)> action )
        {
            exitAction = action;
        }

    private:

        template < typename F, typename R >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(std::ostream& out) const );

        template < typename F, typename R, typename A1 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2, typename A3 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, A3, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2, typename A3, typename A4 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, A3, A4, std::ostream& out) const );

        bool ScanCmds( const std::vector< std::string >& cmdLine )
        {
            for ( auto& cmd: cmds )
                if ( cmd -> Exec( cmdLine, *this ) ) return true;
            return false;
        }

        Cli& cli;
        Menu* current;
        bool run;
        std::ostream& out;
        using Cmds = std::vector< std::unique_ptr< Command > >;
        Cmds cmds;
        std::function< void(std::ostream&)> exitAction;
    };

    // ********************************************************************

    class Menu : public Command
    {
    public:
        // disable value semantics
        Menu( const Menu& ) = delete;
        Menu& operator = ( const Menu& ) = delete;

        Menu() : name(), parent( nullptr ), description() {}

        Menu( const std::string& _name, const std::string& desc = "(menu)" ) :
            name( _name ), parent( nullptr ), description( desc )
        {}

        template < typename F >
        void Add( const std::string& name, F f, const std::string& help = "" )
        {
            // dispatch to private Add methods
            Add( name, help, f, &F::operator() );
        }

        void Add( std::unique_ptr< Command >&& cmd )
        {
            cmds.push_back( std::move(cmd) );
        }

        void Add( std::unique_ptr< Menu >&& menu )
        {
            menu -> parent = this;
            cmds.push_back( std::move(menu) );
        }

        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine[ 0 ] == name )
            {
                session.Current( this );
                return true;
            }
            return false;
        }

        bool ScanCmds( const std::vector< std::string >& cmdLine, CliSession& session )
        {
            for ( auto& cmd: cmds )
                if ( cmd -> Exec( cmdLine, session ) ) return true;
            if ( parent && parent -> Exec( cmdLine, session ) ) return true;
            return false;
        }

        std::string Prompt() const
        {
            return name;
        }

        void MainHelp( std::ostream& out )
        {
            for ( auto& cmd: cmds )
                cmd -> Help( out );
            if ( parent ) parent -> Help( out );
        }

        void Help( std::ostream& out ) override
        {
            out << " - " << name << "\n\t" << description << std::endl;
        }

    private:

        template < typename F, typename R >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(std::ostream& out) const );

        template < typename F, typename R, typename A1 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2, typename A3 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, A3, std::ostream& out) const );

        template < typename F, typename R, typename A1, typename A2, typename A3, typename A4 >
        void Add( const std::string& name, const std::string& help, F& f,R (F::*mf)(A1, A2, A3, A4, std::ostream& out) const );

        const std::string name;
        Menu* parent;
        const std::string description;
        using Cmds = std::vector< std::unique_ptr< Command > >;
        Cmds cmds;
    };

    // ********************************************************************

    class BasicCommand : public Command
    {
    public:
        // disable value semantics
        BasicCommand( const BasicCommand& ) = delete;
        BasicCommand& operator = ( const BasicCommand& ) = delete;

        BasicCommand( const std::string& _name, std::function< void(CliSession&) > f, const std::string& _help = "" ) :
            name( _name ), func( f ), help( _help ) {}
        virtual bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine[ 0 ] == name )
            {
                func( session );
                return true;
            }

            return false;
        }
        virtual void Help( std::ostream& out ) override
        {
            out << " - " << name << "\n\t" << help << std::endl;
        }
    private:
        const std::string name;
        std::function< void(CliSession&) > func;
        const std::string help;
    };

    class FuncCmd : public Command
    {
    public:
        // disable value semantics
        FuncCmd( const FuncCmd& ) = delete;
        FuncCmd& operator = ( const FuncCmd& ) = delete;

        FuncCmd(
            const std::string& _name,
            std::function< void( std::ostream& )> _function,
            const std::string& desc = ""
        ) : name( _name ), function( _function ), description( desc )
        {
        }
        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session )
        {
            if ( cmdLine[ 0 ] == name )
            {
                function( session.OutStream() );
                return true;
            }

            return false;
        }
        void Help( std::ostream& out )
        {
            out << " - " << name << "\n\t" << description << std::endl;
        }
    private:
        const std::string name;
        const std::function< void( std::ostream& )> function;
        const std::string description;
    };

    template < typename T >
    class FuncCmd1 : public Command
    {
    public:
        // disable value semantics
        FuncCmd1( const FuncCmd1& ) = delete;
        FuncCmd1& operator = ( const FuncCmd1& ) = delete;

        FuncCmd1(
            const std::string& _name,
            std::function< void( T, std::ostream& ) > _function,
            const std::string& desc = ""
            ) : name( _name ), function( _function ), description( desc )
        {
        }
        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine.size() != 2 ) return false;
            if ( name == cmdLine[ 0 ] )
            {
                try
                {
                    T arg = boost::lexical_cast<T>( cmdLine[ 1 ] );
                    function( arg, session.OutStream() );
                }
                catch ( boost::bad_lexical_cast & )
                {
                    return false;
                }
                return true;
            }

            return false;
        }
        void Help( std::ostream& out ) override
        {
            out << " - " << name
                << " " << TypeDesc< T >::Name()
                << "\n\t" << description << std::endl;
        }
    private:
        const std::string name;
        const std::function< void( T, std::ostream& )> function;
        const std::string description;
    };

    template < typename T1, typename T2 >
    class FuncCmd2 : public Command
    {
    public:
        // disable value semantics
        FuncCmd2( const FuncCmd2& ) = delete;
        FuncCmd2& operator = ( const FuncCmd2& ) = delete;

        FuncCmd2(
            const std::string& _name,
            std::function< void( T1, T2, std::ostream& ) > _function,
            const std::string& desc = "2 parameter command"
            ) : name( _name ), function( _function ), description( desc )
        {
        }
        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine.size() != 3 ) return false;
            if ( name == cmdLine[ 0 ] )
            {
                try
                {
                    T1 arg1 = boost::lexical_cast<T1>( cmdLine[ 1 ] );
                    T2 arg2 = boost::lexical_cast<T2>( cmdLine[ 2 ] );
                    function( arg1, arg2, session.OutStream() );
                }
                catch ( boost::bad_lexical_cast & )
                {
                    return false;
                }
                return true;
            }

            return false;
        }
        void Help( std::ostream& out ) override
        {
            out << " - " << name
                << " " << TypeDesc< T1 >::Name()
                << " " << TypeDesc< T2 >::Name()
                << "\n\t" << description << std::endl;
        }
    private:
        const std::string name;
        const std::function< void( T1, T2, std::ostream& )> function;
        const std::string description;
    };

    template < typename T1, typename T2, typename T3 >
    class FuncCmd3 : public Command
    {
    public:
        // disable value semantics
        FuncCmd3( const FuncCmd3& ) = delete;
        FuncCmd3& operator = ( const FuncCmd3& ) = delete;

        FuncCmd3(
            const std::string& _name,
            std::function< void( T1, T2, T3, std::ostream& ) > _function,
            const std::string& desc = "3 parameters command"
            ) : name( _name ), function( _function ), description( desc )
        {
        }
        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine.size() != 4 ) return false;
            if ( name == cmdLine[ 0 ] )
            {
                try
                {
                    T1 arg1 = boost::lexical_cast<T1>( cmdLine[ 1 ] );
                    T2 arg2 = boost::lexical_cast<T2>( cmdLine[ 2 ] );
                    T3 arg3 = boost::lexical_cast<T3>( cmdLine[ 3 ] );
                    function( arg1, arg2, arg3, session.OutStream() );
                }
                catch ( boost::bad_lexical_cast & )
                {
                    return false;
                }
                return true;
            }

            return false;
        }
        void Help( std::ostream& out ) override
        {
            out << " - " << name
                << " " << TypeDesc< T1 >::Name()
                << " " << TypeDesc< T2 >::Name()
                << " " << TypeDesc< T3 >::Name()
                << "\n\t" << description << std::endl;
        }
    private:
        const std::string name;
        const std::function< void( T1, T2, T3, std::ostream& )> function;
        const std::string description;
    };

    template < typename T1, typename T2, typename T3, typename T4 >
    class FuncCmd4 : public Command
    {
    public:
        // disable value semantics
        FuncCmd4( const FuncCmd4& ) = delete;
        FuncCmd4& operator = ( const FuncCmd4& ) = delete;

        FuncCmd4(
            const std::string& _name,
            std::function< void( T1, T2, T3, T4, std::ostream& ) > _function,
            const std::string& desc = "4 parameters command"
            ) : name( _name ), function( _function ), description( desc )
        {
        }
        bool Exec( const std::vector< std::string >& cmdLine, CliSession& session ) override
        {
            if ( cmdLine.size() != 5 ) return false;
            if ( name == cmdLine[ 0 ] )
            {
                try
                {
                    T1 arg1 = boost::lexical_cast<T1>( cmdLine[ 1 ] );
                    T2 arg2 = boost::lexical_cast<T2>( cmdLine[ 2 ] );
                    T3 arg3 = boost::lexical_cast<T3>( cmdLine[ 3 ] );
                    T4 arg4 = boost::lexical_cast<T4>( cmdLine[ 4 ] );
                    function( arg1, arg2, arg3, arg4, session.OutStream() );
                }
                catch ( boost::bad_lexical_cast & )
                {
                    return false;
                }
                return true;
            }

            return false;
        }
        void Help( std::ostream& out ) override
        {
            out << " - " << name
                << " " << TypeDesc< T1 >::Name()
                << " " << TypeDesc< T2 >::Name()
                << " " << TypeDesc< T3 >::Name()
                << " " << TypeDesc< T4 >::Name()
                << "\n\t" << description << std::endl;
        }
    private:
        const std::string name;
        const std::function< void( T1, T2, T3, T4, std::ostream& )> function;
        const std::string description;
    };

    // ********************************************************************

    // Cli implementation

    inline Cli::Cli( std::unique_ptr< Menu >&& _rootMenu, std::function< void( std::ostream& )> _exitAction ) :
        rootMenu( std::move(_rootMenu) ),
        global( std::make_unique< Menu >() ),
        exitAction( _exitAction )
    {
        global -> Add( std::make_unique< BasicCommand >(
                "help",
                [](CliSession& s){ s.Help(); },
                "This help message"
            )
        );
    }

    inline void Cli::ExitAction( std::function< void(std::ostream&)> action )
    {
        exitAction = action;
    }

    inline bool Cli::ScanCmds( const std::vector< std::string >& cmdLine, CliSession& session )
    {
        return global -> ScanCmds( cmdLine, session );
    }

    inline void Cli::MainHelp( std::ostream& out )
    {
        global -> MainHelp( out );
    }

    // CliSession implementation

    inline bool CliSession::Feed( const std::string& cmd )
    {
        std::vector< std::string > strs;
        boost::split( strs, cmd, boost::is_any_of( " \t\r\n" ), boost::token_compress_on );
        // remove null entries from the vector:
        strs.erase(
            std::remove_if(
                strs.begin(),
                strs.end(),
                std::bind( &std::string::empty, std::placeholders::_1 )
            ),
            strs.end()
        );
        if ( strs.size() == 0 ) return true; // just hit enter
        // global cmds check
        bool found = cli.ScanCmds( strs, *this );
        if ( !found ) found = ScanCmds( strs );
        // if the user gave the exit command:
        if ( ! run )
        {
            cli.ExitAction( out );
            return false;
        }
        // root menu recursive cmds check
        if ( !found ) found = current -> ScanCmds( strs, *this );
        // error msg if not found
        if ( !found ) out << "Command unknown: " << cmd << std::endl;
        return true;
    }

    inline void CliSession::Prompt()
    {
        out << current -> Prompt() << "> " << std::flush;
    }

    inline void CliSession::Help()
    {
        out << "Commands available:" << std::endl;
        cli.MainHelp( out );
        for ( auto& cmd: cmds )
            cmd -> Help( out );
        current -> MainHelp( out );
    }

    template < typename F, typename R >
    void CliSession::Add( const std::string& name, const std::string& help, F& f,R (F::*)(std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd >( name, f, help ) );
    }

    template < typename F, typename R, typename A1 >
    void CliSession::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd1< A1 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2 >
    void CliSession::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd2< A1, A2 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2, typename A3 >
    void CliSession::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, A3, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd3< A1, A2, A3 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2, typename A3, typename A4 >
    void CliSession::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, A3, A4, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd4< A1, A2, A3, A4> >( name, f, help ) );
    }

    // Menu implementation

    template < typename F, typename R >
    void Menu::Add( const std::string& name, const std::string& help, F& f,R (F::*)(std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd >( name, f, help ) );
    }

    template < typename F, typename R, typename A1 >
    void Menu::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd1< A1 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2 >
    void Menu::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd2< A1, A2 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2, typename A3 >
    void Menu::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, A3, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd3< A1, A2, A3 > >( name, f, help ) );
    }

    template < typename F, typename R, typename A1, typename A2, typename A3, typename A4 >
    void Menu::Add( const std::string& name, const std::string& help, F& f,R (F::*)(A1, A2, A3, A4, std::ostream& out) const )
    {
        cmds.push_back( std::make_unique< FuncCmd4< A1, A2, A3, A4> >( name, f, help ) );
    }

} // namespace

#endif

