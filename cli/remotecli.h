/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef REMOTECLI_H_
#define REMOTECLI_H_

#include <memory>
#include "cli/cli.h"
#include "cli/server.h"

namespace cli
{

class TcpCliSession : public Session
{
public:
    TcpCliSession( boost::asio::ip::tcp::socket socket, Cli& _cli, std::function< void(std::ostream&)> exitAction ) :
        Session( std::move( socket ) ),
        cliSession( _cli, this -> OutStream() )
    {
        cliSession.ExitAction( exitAction );
        cliSession.Add( std::make_unique< FuncCmd >( "exit", [this](std::ostream&){ cliSession.Exit(); }, "Terminate this session" ) );
    }

protected:

    virtual void OnConnect() override
    {
        // to specify hexadecimal value as chars we use
        // the syntax \xVVV
        // and the std::string ctor that takes the size,
        // so that it's not null-terminated
        //std::string msg{ "\x0FF\x0FD\x027", 3 };
        waitAck = true;
        //std::string iacDoSuppressGoAhead{ "\x0FF\x0FD\x003", 3 };
        //this -> OutStream() << iacDoSuppressGoAhead << std::flush;

        // https://www.ibm.com/support/knowledgecenter/SSLTBW_1.13.0/com.ibm.zos.r13.hald001/telcmds.htm

        std::string iacDoLineMode{ "\x0FF\x0FD\x022", 3 };
        this -> OutStream() << iacDoLineMode << std::flush;
        std::string iacSbLineMode0IacSe{ "\x0FF\x0FA\x022\x001\x000\x0FF\x0F0", 7 };
        this -> OutStream() << iacSbLineMode0IacSe << std::flush;
        std::string iacWillEcho{ "\x0FF\x0FB\x001", 3 };
        this -> OutStream() << iacWillEcho << std::flush;
/*
        constexpr char IAC = '\x0FF'; // 255
        constexpr char DO = '\x0FD'; // 253
        constexpr char VT100 = '\x030'; // 48

        this -> OutStream() << IAC << DO << VT100 << std::flush;
*/
        //cliSession.Prompt();
    }
    virtual void OnDisconnect() override {}
    virtual void OnError() override {}
    virtual void OnDataReceived( const std::string& data ) override
    {
        if (waitAck)
        {
            if ( data[0] == '\x0FF' )
            {
                // TODO
                for ( size_t i = 0; i < data.size(); ++i )
                    std::cout << static_cast<int>( data[i] & 0xFF ) << ' ';
                std::cout << std::endl;
            }
            waitAck = false;
/*
            std::string iacWillSuppressGoAhead{ "\x0FF\x0FB\x003", 3 };
            if ( data == iacWillSuppressGoAhead )
            {
                waitAck = false;
                cliSession.Prompt();
            }

            else
                Disconnect();
*/
        }
        else
        {
            for ( size_t i = 0; i < data.size(); ++i )
                Feed( data[i ] );
/*
            auto str = data;
            // trim trailing spaces
            std::size_t endpos = str.find_last_not_of(" \t\r\n");
            if( std::string::npos != endpos ) str = str.substr( 0, endpos+1 );

            if ( cliSession.Feed( str ) ) cliSession.Prompt();
            else Disconnect();
*/
        }
    }
private:
    void Feed( char c )
    {
        switch ( c )
        {
        case 0: break;
        case '\n':
        case '\r':
        {
            // trim trailing spaces
            std::size_t endpos = buffer.find_last_not_of(" \t\r\n");
            if( std::string::npos != endpos ) buffer = buffer.substr( 0, endpos+1 );
            if ( cliSession.Feed( buffer ) ) cliSession.Prompt();
            else Disconnect();

            buffer.clear();
            break;
        }
        default:
            Echo( c );
            buffer += c;
        }
    }
    void Echo( char c )
    {
        this -> OutStream() << c << std::flush;
    }

    std::string buffer;
    CliSession cliSession;
    bool waitAck = false;
};

class CliServer : public Server
{
public:
    CliServer( boost::asio::io_service& ios, short port, Cli& _cli ) :
        Server( ios, port ),
        cli( _cli )
    {}
    void ExitAction( std::function< void(std::ostream&)> action )
    {
        exitAction = action;
    }
    virtual std::shared_ptr< Session > CreateSession( boost::asio::ip::tcp::socket socket ) override
    {
        return std::make_shared< TcpCliSession >( std::move( socket ), cli, exitAction );
    }
private:
    Cli& cli;
    std::function< void(std::ostream&)> exitAction;
};

} // namespace

#endif // REMOTECLI_H_

